const path = require('path');
const fs = require('fs-extra');
const commonjs = require('@rollup/plugin-commonjs');
const nodeExternals = require('rollup-plugin-node-externals');
const { nodeResolve } = require('@rollup/plugin-node-resolve');
const json = require('@rollup/plugin-json');
const alias = require('@rollup/plugin-alias');
const replace = require('@rollup/plugin-replace');
const visualizer = require('rollup-plugin-visualizer');
const { babel } = require('@rollup/plugin-babel');
const postcss = require('rollup-plugin-postcss');
const nodePolyfills = require('rollup-plugin-node-polyfills');
const mergedirs = require('merge-dirs').default;
const { getPackagesList } = require('./get-packages-list');

async function createPackageConfig(config) {
  const packageJson = JSON.parse(
    fs.readFileSync(path.join(config.basePath, './package.json')).toString('utf-8')
  );
  const pkgList = await getPackagesList();

  const aliasEntries = pkgList.map((pkg) => ({
    find: new RegExp(`^${pkg.packageJson.name}`),
    replacement: path.resolve(pkg.path, 'src'),
  }));

  const externalDirname = '_externals';

  const plugins = [
    postcss(),
    nodeExternals(),
    nodeResolve({ extensions: ['.js'] }),
    nodePolyfills(),
    babel({
      presets: ['@babel/preset-react'],
      plugins: ['@babel/plugin-transform-runtime'],
      exclude: ['node_modules/**'],
      babelHelpers: 'runtime',
    }),
    commonjs(),
    json(),
    alias({ entries: aliasEntries }),
    replace({ preventAssignment: true, 'process.env.NODE_ENV': JSON.stringify('development') }),
    {
      name: 'Custom Rollup Plugin`',
      generateBundle: (options, bundle) => {
        // Clear output dir
        if (fs.existsSync(options.dir)) {
          fs.emptyDirSync(options.dir);
        }

        Object.entries(bundle).forEach((entry) => {
          const cdSteps = entry[0]
            .replace(/^packages\/.+\/src\//g, '')
            .split('/')
            .slice(0, -1)
            .map(() => '..')
            .join('/');

          if (entry[0].match(/.*(.css.js)$/)) {
            // this line only runs for .css.js files, which were generated by the postcss plugin.
            // depending on the use-case, the relative path to style-inject might need to change
            bundle[entry[0]].code = entry[1].code
              .replace(/[..\/]+node_modules/g, cdSteps + '/node_modules')
              .replace(/node_modules\/style-inject\//g, externalDirname + '/style-inject/');
          }

          if (
            entry[0].match(/.*(.styles.js)$/) ||
            packageJson.name.indexOf('calendars') > 0 ||
            packageJson.name.indexOf('editors') > 0 ||
            packageJson.name.indexOf('leemons') > 0
          ) {
            bundle[entry[0]].code = entry[1].code
              .replace(/[..\/]+node_modules/g, cdSteps + '/node_modules')
              .replace(/node_modules\//g, externalDirname + '/');
          }

          return;
        });
      },
      writeBundle: (options, bundle) => {
        if (fs.existsSync(options.dir + '/node_modules')) {
          fs.renameSync(options.dir + '/node_modules', options.dir + '/' + externalDirname);
          mergedirs(
            options.dir + '/packages/' + packageJson.name.split('/')[1] + '/src',
            options.dir
          );
          fs.emptyDirSync(options.dir + '/packages');
          fs.rmdirSync(options.dir + '/packages');
        }
      },
    },
  ];

  let externals;

  if (config.format === 'umd') {
    externals = [
      ...(config?.externals || []),
      ...Object.keys({
        ...packageJson.peerDependencies,
      }),
    ];
  } else {
    externals = [
      '@mantine/styles',
      /@styled\/icons/,
      /@babel\/runtime/,
      ...(config?.externals || []),
      ...Object.keys({
        ...packageJson.peerDependencies,
        ...packageJson.dependencies,
      }),
    ];
  }

  const output = {
    name: packageJson.name,
    format: config.format,
    externalLiveBindings: false,
    sourcemap: config.sourcemap,
  };

  if (config.format === 'es') {
    output.dir = path.resolve(config.basePath, 'esm');
    output.preserveModules = true;
  }

  if (config.format === 'cjs') {
    output.dir = path.resolve(config.basePath, 'cjs');
    output.preserveModules = true;
    output.exports = 'named';
  }

  if (config.format === 'umd') {
    output.file = path.resolve(config.basePath, 'lib/index.umd.js');
    output.globals = {
      ...config.globals,
      ...pkgList
        .map((pkg) => ({
          [pkg.packageJson.name]: pkg.packageJson.name,
        }))
        .reduce((globals, pkgGlobal) => ({ ...globals, ...pkgGlobal }), {}),
      react: 'React',
      dayjs: 'dayjs',
      'react-dom': 'ReactDOM',
    };
  }

  if (config.analyze && config.format === 'umd') {
    plugins.push(
      visualizer({
        title: packageJson.name,
        filename: path.join(config.basePath, 'lib/stats.html'),
        projectRoot: path.join(config.basePath, 'src'),
        sourcemap: true,
        gzipSize: true,
      }),
      visualizer({
        title: packageJson.name,
        filename: path.join(config.basePath, 'lib/stats.json'),
        projectRoot: path.join(config.basePath, 'src'),
        json: true,
        sourcemap: true,
        gzipSize: true,
      })
    );
  }

  // Creating regexes of the packages to make sure subpaths of the
  // packages are also treated as external
  const regexesOfPackages = externals.map((packageName) => new RegExp(`^${packageName}(\/.*)?`));

  return {
    input: config?.entry || path.resolve(config.basePath, 'src/index.js'),
    output,
    external: regexesOfPackages,
    plugins,
  };
}

module.exports = createPackageConfig;
